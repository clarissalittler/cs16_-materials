* Meta-meta, delete eventually
 Video series that this is loosely based on has the progression of:
 + basic I/O, variables, string type
 + int/float/double types and arithmetic
 + if-statements and booleans
 + table formatting
 + first functions, abstracting table formatting to make it better and less cluttered
 + first while loops
 + if-statements again with && and ||, &c.
 + guessing game
 + arrays and for-loops
 + error handling with cin
   + how to make a better pets database
 + substr, find, and iterating through strings
 + switch/case
 + arrays again, pointer-and-a-promise
 + revisiting petDB one more time with structs
 + char arrays

 Projects I give
 + Write tiny programs
 + Personality quiz
 + Rock paper scissors
 + Store-front
 + Refactoring
* Meta-commentary
** What is this text?
This is a free and open source text on learning the C++ language that can be freely shared with attribution under a CC-BY license. It comes in both a basic and interactive form. If you want to borrow from it, please do! 

[instructions for the interactive version should go here]
** Roadmap
 Where we're headed:
 
* Introduction
** Why C++?
C++ is a fascinating old-ish language. It blends a combination of "high-level" and "low-level" features. Now those might sound like rather judgy descriptors, like "high-level" is better than "low-level", but they're just different ways of looking at programming that---for our purposes---serve as a segue into talking about what programming is.
** What is programming? A high-level perspective
Programming is the practice of telling a computer to do things. How the computer does things doesn't entirely matter, what you care about is describing the /logic/, the precise sequence of what steps should happen, of the program to the computer.

You describe this logic in a special kind of language that's suitable for explaining ideas to the computer. These /programming languages/[fn:1] are very different than human languages, focused on precision at the expense of ease and flexibility. Have you ever tried to explain to someone complicated instructions entirely through text without being able to point or gesture or demonstrate it yourself? It's not easy! Often our instructions are /ambiguous/, they're unclear or can be read in different---equally plausible---ways.

Programming isn't hard because programming languages are bad. Programming is hard because writing good instructions is hard and programming languages are designed to never let you write unclear instructions.

A good programming language is, then, a thing that lets you express instructions precisely but is still relatively easy to think-in and read.
** What is programming? A low-level perspective
Computers are, fundamentally, just super-calculators acting on numbers. Everything you see and deal with on a computer is, under the hood, just a number. The pixels you see lit up on your screen are just encoded as a series of numbers. Your internet traffic is a series of numbers. That emotional-support video essay you have on in the background for the 20th time[fn:2] is just a series of numbers.

These numbers aren't even represented the normal way you would think of numbers, instead each number is just a sequence of 1s and 0s that the computer's /processor/, well, /processes/.

The computer's processor takes these sequences of 1s and 0s and does simple things like adding, subtracting, and multiplying them together.

It's kind of amazing that something so simple can, at a large enough scale, do all the things we do with computers, right?

Now, thinking of how to turn "streaming a video" into "a bunch of arithmetic operations" is /really hard/. You have to be an electrical engineer or computer scientist to figure out how to do that and it will /still/ take you a really long, error prone, time.

Programming languages are ways of turning concepts that make more sense to us, like "if *this* then *that*", into simple number-crunching that the processor understands. The problem, though, is that turning concepts that are easy for us into arithmetic is hard to do efficiently. If you do it badly, the resulting programming is /slow/, takes a ton of memory, and might just be completely unusable.

A good programming language is, then, a thing that lets you have control over how the logic of the program you want gets turned into number-crunching at the end: you control the resources the program uses and the way it runs.
** Why C++, redux
C++ is a programming language that tries to meet the tension of making it easy to focus on the logic while still having control over the low-level execution of the program as instructions to the processor.

That isn't to say it's perfect: no programming language is. Every single language is a series of design decisions that reflect the ideas, style, and goals of the authors of the language.

Which is something I cannot emphasize enough! Programming languages are made by people and there's no "best" language, there is---at most---a best language for a particular project given the people and technical goals involved.

** Why learn programming in the age of LLMs
This is a /weird/ topic to have to bring up in an introduction to computer science text, but I think it's necessary. There's a lot of talk these days about how programming will be obsolete, "English is the new programming language", &c.

These arguments are a little silly. Not because large language models are bad at coding---they're not---or because they're going to hit a ceiling soon---they /might/ not---but rather because there will always need to be people who understand

 + what the code is doing
 + how the code does it

so that there are people who can guide the AI, override the AI, or decide that the task is outside the capabilities of the AI and get their hands dirty.

In other words, we will always need programmers. In fact, a personal prediction of the author is that the average programmer will have to be better than ever: a master of the /high/ and /low/ levels of programming. In a world where non-programmers can "vibe code" simple proofs of concept, there may well be even more need for competent programmers to take those simple programs and turn them into robust products.

By analogy, this is like how home CAD software and 3D printers didn't kill manufacturing but rather let people quickly prototype ideas that they then pay engineers to turn into production lines.
* Your First Programs
** DONE Hello World
So the origins of making a program that says "Hello, World" as your first program started with Kernigan and Ritchie in their introduction to the C programming language. The basic idea was that if you can get a simple program to compile[fn:7] that prints something out to the screen then you're already over the worst hurdles of learning a programming language.

This might seem like an odd perspective, right, because you've just barely begun learning the language but it makes a lot of sense if you're a pre-internet 1970s programmer who doesn't have any obvious references for how to run this stupid compiler thing or even what a program is supposed to look like.

So that being said, here's "Hello World" in C++
#+begin_src cpp :tangle codesnips/hello.cpp
  #include <iostream>
  using namespace std;

  int main(){
    cout << "Hello, World" << endl;

    return 0;
  }
#+end_src
Let's break down the first few lines:

#+begin_src cpp
  #include <iostream>
  using namespace std;
#+end_src

These first two lines, unfortunately, will seem like the worst kind of magic for a bit. But, basically, what's happening is that the ability to even print things out in C++ is not a part of the "core" language but a library that is always included as part of the C++ compiler, a "StandarD Library" if you will (a-ha! that must be what "std" is short for here). To understand why things that seem so critical are not "in the language" by default, it helps to know that C++ (like C before it) is a language that's used for coding things like operating systems or programming little tiny computers called microcontrollers that have a millionth of the memory on your phone.

When programming under these conditions you really need to be able to control what goes into the compiled code, because maybe you want to keep your final program as tiny as possible and you don't want allll the code that goes into the seemingly unremarkable ability to print to a screen to get included. Because that's part of what the compiler does: it takes all the supporting code that's needed and includes it (oh, hey, that word again). It's kind of like if you're writing a paper and you want to make sure that someone can understand everything you're saying and all the references you're citing without access to a library or internet. Then instead of just having citations you also need to include all the other things you cite along with the paper as appendices so that someone can read it without having to track anything else down. That's what the compiler is doing.

So the first line here is /including/ the code for printing and the second line is saying "oh, hey, we're going to be using the standard library a lot, so we want to just refer to things *from* the standard library as simply as possible". If you /don't/ have this line you have to take every standard library function and put =std::= in front of it. It's annoying! We don't like doing this!

Okay, with that digression aside now we get into heart of the program
#+begin_src cpp
  int main(){
    cout << "Hello, World" << endl;
  
    return 0;
  }
#+end_src
The first line here is declaring a function, a chunk of code that has a name. In this case the name is "main". Every C++ program *must* have a function called "main" so the compiler knows, when building the stand-alone program, where to even start executing the code. Now, in principle there are different ways this could be handled, but most programming languages follow this convention of having a function called "main". When I call it a convention it's a lot like how every *human* language has a convention about how it has to be read. For example, the language I'm writing these notes in, English, has the convention that you start at the top of the text and read from left to right.

#+begin_src cpp
  int main() {
#+end_src
Let's dig into this function declaration
 + =int= means that when the function /ends/ it has to give back an integer, a whole number
 + =main= is the name of the function
 + =()= is where you would put the name of data you have to give the function for it to run, its /arguments/, but =main= doesn't *have any* so instead you denote that =main= "needs nothing" by just putting =()=.
 + Finally, we have an open curly-brace which is the way you tell the compiler "okay I've finished declaring the function now here's the code that runs inside the function". This is matched by a closed curly-brace at the end that denotes "okay I'm done writing the function".

Okay we're almost done! There's just two more lines. The first
#+begin_src cpp
  cout << "Hello, World" << endl;
#+end_src
as you can probably guess is what actually prints the line "Hello, World". Think of =cout= as the /target/ you're sending text to to be printed out. You send things to it with the =<<= symbol. The text you're sending is in quotation marks. In C++, like most programming languages, you denote text-as-data with double-quotes.[fn:2] The other thing we need to explain here is the =endl=, which is just the way of saying "end this line and start a new one".

So to understand the final line of the function, =return 0;=, remember how we said that when the function ends it has to give back a whole number? Well this is the line that says that when the function ends that it's going to hand back the number 0. This is an old convention that dates back to the days of /unix/, where if everything goes well a program should return 0.
*** Exercises
1. *Basic*: Modify Hello World to print your name and favorite programming joke on separate lines.
2. *Intermediate*: Create a program that prints a simple ASCII art box with "Hello" inside it. For example:
   #+begin_example
   *********
   * Hello *
   *********
   #+end_example
** DONE Why semicolons?
Already, you've probably noticed all the semicolons (the ";" symbols) in this code and this might be one of the first times in your life you've really needed to use them! It's reasonable to be asking "why, though?" now.

The answer is that C++ is an old language, that also borrows the syntax of /even older/ languages. Part of being "an old language" means that it has weird bits that come from a time we were both a lot worse at making compilers and computers were also much much much [&c.] much slower. So the semicolons are a way to note, for the compiler, "hi this is end of a line of code". This is not an essential feature of all programming languages and, indeed, more modern languages have much more elegant ways to denote the end of one line and the start of another.

But once a language, like C++, exists and starts being wildly used you can't do things like "change fundamental features of the syntax"

So, yes, *most* lines need semi-colons at the end. The lines that don't need a semicolon are
 + lines that end with ={= or =}= (with one annoying exception we'll get to)
 + lines that start with #
 + comments, which we haven't discussed yet
** TODO How to run examples [0/3]
*** TODO In-browser
*** TODO In onlinegdb
*** TODO Locally in the terminal
** TODO More early steps [7/8]
*** DONE Echoing text and string types
So we've already done a non-trivial amount of work because we've learned to compile a file, run it, and have it print something out the screen.

Now here's our first program that we're going to use to explain
 + variables
 + our first data type, string
 + how to read data in from the command line

Go ahead and first compile and run this code. You should get a command prompt that lets you type something, hit enter, and then get what you typed printed back onto the screen. 
 
 #+begin_src cpp 
   #include <iostream>
   using namespace std;

   int main(){
     string stuff;
     cout << "Enter a thing: " << endl;
     cin >> stuff;

     cout << "You said: " << stuff << endl;

     return 0;
   }
 #+end_src

Now that you've tried it and seen that it works, let's explain it!
 
 Okay, so these first lines are what we've already seen before:
 #+begin_example
   #include <iostream>
   using namespace std;
 #+end_example
We'll reiterate that these lines let us
 + load in the code needed for us to do things like read and write information from the terminal
 + *not* have to preface all this code with =std::= because that gets really annoying to type!

 From there we have
 #+begin_src cpp
   int main(){
   ...
   }
 #+end_src
which, again, is a way of declaring a named chunk of code. A very specific named chunk of code: =main=, the function that is needed as the "entry point" of final program. We'll make our own functions soon enough, but for now know that this is a function and represents the pattern of how they're made.

The next line =string stuff;= needs some explanation. In C++, like a lot of other programming languages, in order to store information you need to make a container and give it a name. In this case we're naming a container =stuff=. Now, what's up with the text =string= that comes before that?

Well, much like the =int= we saw before =main= this is a *type*[fn:3], it's a signifier for the /form/ of data we're talking about. =int= is the type that corresponds to whole numbers. =string= is the type that corresponds to text-as-data, like what we saw in our /Hello, World/ program where the text "Hello, World" was inside the program in quotes like ="Hello, World"=.

So our container =stuff= /can/ contain strings but it's currently empty. We're going to put something in it, though, by using =cin=! =cin= is the opposite of =cout= and, rather than printing something out to the screen, lets you read text *into* the program by typing and hitting enter.

After the =cin= has run,  we have something /in/ our container and then we can grab the contents of the container using the container name which, in this case, is simply =stuff=.

So when we want to print out the contents of =stuff= we say =cout << "You said: " << stuff << endl;"=.

We also end with =return 0;= because we're very good programmers and *never* forget to put this in our files.[fn:6]
*** Exercises
1. *Basic*: Ask for first and last name separately, then print them together in the format "Last, First".
2. *Intermediate*: Ask for three words and print them in reverse order (if user enters "cat dog bird", print "bird dog cat").
3. *Challenge*: Create a Mad Libs program that asks for a noun, verb, adjective, and adverb, then inserts them into a story template like: "The [adjective] [noun] decided to [verb] [adverb]."
*** Explore: What's in a name?
 Try changing the name of "stuff" in the program above. Be careful that when you /rename/ the variable that you rename it consistently and change every use of the name "stuff" in the program. Come back and read on after you're done.

 Did anything change? The answer is almost certainly "no!". C++ doesn't /care/ what containers are named as long as you label them correctly. You could have, confusingly, named your text-holding variable to =thisIsANumberNotAString= and the program would still work just fine. There's nothing in the C++ compiler that actually "knows" what the name you gave a variable means.

 That doesn't mean naming variables "hinder" or "boopsboops" is a good idea. There's an old saying that you need to write your code so it's understandable by a total stranger, because that stranger is likely to be *you* in a few months.

 So be kind to your future self and user variable names that make sense!
*** DONE What's in an empty variable?
Now, when we declare a variable we're making a container, but is there anything *in* the container at that point? Well let's see![fn:5]

#+begin_src cpp :tangle codesnips/noStringInit.cpp
  #include <iostream>
  using namespace std;

  int main(){
    string stuff;
    cout << "And our string holds..." << stuff << endl;
    return 0;
  }
#+end_src

If I run this on my computer, I get an output of "And our string holds..." and nothing else. In this case, =stuff= contains the empty string "" that corresponds to no text at all. That seems like a pretty reasonable thing for an empty container to hold!

What about if we instead make an empty int?

#+begin_src cpp :tangle codesnips/noIntInit.cpp
  #include <iostream>
  using namespace std;

  int main(){
    int stuff;
    cout << "And our int holds..." << stuff << endl;
    return 0;
  }
#+end_src

Well I ran this once and got "And our int holds...779647075". Oh dear /dot dot dot/ that seems like a very *not* great thing to have as a default value!

Okay, and now we get into the punchline. The reason why I'm specifying "on my computer" and "when I run this" is that the answers could actually change between computers and compilers! You really, really, really should *never* use an empty variable because you can guarantee exactly nothing about what it will do.
*** TODO Advanced: What /is/ a container?
At this point you might be wondering "what /are/ these containers, these /variables/, anyway?". What does it really mean for the compiler to make space for data? To answer that we need to get into some more details about how data is stored in a computer.
**** TODO All we ever were, just zeros and ones
Computers, the modern digital computer we've all settled on, operates fundamentally on Os and 1s. Why? Because in the end you can think of the fundamental atom of the computer, the transistor, as an electrical on-off switch. If it's "on" it lets current flow, if it's "off" it does not. The brilliance of digital computers is in cleverly encoding /everything/ we do into patterns of these ons and offs. First, to explain /that/ we need to review how we write numbers in the normal way.

When we write a number like 42367 this is shorthand for =40000 + 2000 + 300 + 60 + 7=. You may have learned to describe this as the "ones place", "the tens place", "the hundreds place", &c. We can write this even more compactly as

=4*10^4 + 2*10^3 + 3*10^2 + 6*10^1 + 7*10^0=

using the fact that /anything/ to the zeroth power is just one.

This is called the "base ten" representation of numbers because it's a sequence of powers of ten. We can do bases in other numbers though and you might see where we're going with this: computers work with "base two" numbers, also called /binary/.

A binary number like 10010 is thus a way of writing =1*2^4 + 0*2^3 +0*2^2 + 1*2^1 + 0*2^0=, which is actually the number =16 + 0 + 0 + 2 + 0= or =18=.

We're not going to go deep into how different kinds of data are represented /as/ numbers, but we'll simply say that *everything* on a computer is fundamentally understood as a binary number.

**** TODO Memory and storage
*** DONE Arithmetic and such in C++
Arithmetic in C++, like most programming languages, is meant to look a lot like the arithmetic operations you're used to. You can test out some basic operations with the following code. Note that this example shows us that you can use =cin= with types other than =string=.

#+begin_src cpp :tangle codesnips/arith1.cpp
  #include <iostream>
  using namespace std;

  int main(){
    int num1;
    int num2;
    int num3 = 5; // look, we're giving a variable a value at the same time as we make it

    cout << "Enter a number:  ";
    cin >> num1;

    cout << "Enter another number: ";
    cin >> num2;

    cout << "Adding numbers: " << num1 + num2 << endl;
    cout << "Subtracting numbers: " << num1 - num2 << endl;
    cout << "Multiplying numbers: " << num1 * num2 << endl;
    cout << "Dividing numbers .....?: " << num1 / num2 << endl;

    return 0;
  }
#+end_src
So this probably *mostly* went the way you expected but when you ran this code were you surprised by anything related to division? If you weren't, try entering 5 for =num1= and 3 for =num2=. You'll see that =5/3= is computed as 1.

Why on earth is that true? Well, because =num1= and =num2= are *whole numbers* and 3 goes into 5 only once.

Okay, but what if we want to deal with fractional numbers? That's when we introduce /floats/ and /doubles/. These are both kinds of "floating point numbers". The term floating point sounds weird but the point (haha) is that these are numbers that allow for decimal points in them and don't have a fixed number of digits to the left or right of the decimal.

Okay, so why are there two different types? Well, one is smaller than the other. No, this doesn't strictly mean it's for smaller numbers. It's also for "less precise" of numbers.[fn:8] If you need more accurate representations of non-whole numbers, you should use a =double=. Most of the time, folks recommend just defaulting to =double= instead of =float=. You might see me sometimes still use =float= for things where we know the numbers are small and precision doesn't matter.

So let's try this program again with =double= s instead of =int=.
#+begin_src cpp :tangle codesnips/arith2.cpp
  #include <iostream>
  using namespace std;

  int main(){
    double num1;
    double num2;

    cout << "Enter a number:  ";
    cin >> num1;

    cout << "Enter another number: ";
    cin >> num2;

    cout << "Adding numbers: " << num1 + num2 << endl;
    cout << "Subtracting numbers: " << num1 - num2 << endl;
    cout << "Multiplying numbers: " << num1 * num2 << endl;
    cout << "Dividing numbers: " << num1 / num2 << endl;

    return 0;
  }
#+end_src
There, that's probably more what you would have expected from division.

Note that =cin= keeps working no matter what type of container we're trying to fill with it! There's definitely no possibility that is going to go wrong later in a really annoying way! Foreshadowing!
*** Exercises
1. *Basic*: Calculate the area and perimeter of a rectangle from user input (length and width).
2. *Intermediate*: Create a tip calculator that asks for bill amount and tip percentage, then shows the tip amount and total.
3. *Challenge*: Implement a compound interest calculator that asks for principal, annual rate, time in years, and number of times compounded per year. Use the formula: A = P(1 + r/n)^(nt)
*** TODO Booleans and personality tests
Okay, if all we could do with code was straight-line programs that just do a sequence of calculations then we'd basically just have the equivalent of a calculator but arguably more annoying.

Our first real important ability is the ability to make /choices/. "Do I do /this/ or /that/?" Let's look at an example.

#+begin_src cpp :tangle codesnips/firstIf.cpp
  #include <iostream>
  using namespace std;

  int main(){

    double num1;
    double num2;

    cout << "Enter a number: ";
    cin >> num1;
    cout << "Enter another number: ";
    cin >> num2;

    cout << "If the first number - the second number is greater than 10, it will print 'beep', otherwise 'boop'" << endl;

    if(num1 - num2 > 10){
      cout << "beep" << endl;
    }
    else{
      cout << "boop" << endl;
    }

    return 0;
  }

#+end_src

Let's break down the new part here:
  =if(num1 - num2 > 10){= this lets us ask the question "is num1 minus num2 greater than 10"? /If/ the answer to this question is "yes", then all the code between this curly-brace and the next curly brace happens. If the answer is "no", then the code between the curly-brace after =else= and the closing curly-brace after that is run.

 A way you could read this in English is provided in the text that prints out "If the first number - the second number is greater than 10, it will print 'beep', otherwise 'boop'".

 We refer to this as an "if-statement".

 An if-statement doesn't have to have the =else= part, though.

 Consider this program that makes sure an integer entered is positive
 #+begin_src cpp :tangle codesnips/positeev.cpp
   #include <iostream>
   using namespace std;

   int main(){
     int num;
     cout << "Enter a positive number (if it's not positive we'll *make* it positive): ";
     cin >> num;

     if(num < 0){
       num = -num;
     }

     cout << "Your number: " << num << endl;
     return 0;
   }
 #+end_src

 Okay, so let's talk a bit more about what kinds of "questions" you can ask. "Question" is also a kind of data and has a type. That type is called =bool=, sometimes called a "boolean", named after the mathematician "George Boole" who was extremely influential in the development of formal logic.

 The type =bool= has two elements: =true= and =false=. You can use these inside your if-statements, like the following program:

 #+begin_src cpp :tangle codesnips/truth1.cpp
   #include <iostream>
   using namespace std;

   int main(){
     bool isItQuestionMark = true;

     if(isItQuestionMark){
       cout << "It's true" << endl;
     }
     else {
       cout << "It's not" << endl;
     }
     return 0;
   }
 #+end_src

There are all sorts of questions you can ask, such as
 + ~a == b~ are two things equal to each other
 + ~a != b~ are two things not equal
 + ~a > b~ is a greater-than b
 + ~a < b~ is a less-than b

You can also take the inverse of a question but putting =!= in front of it. So we can have

#+begin_src cpp :tangle codesnips/notTruth.cpp
  #include <iostream>
  using namespace std;

  int main(){

    if(!true){
      cout << "This shouldn't get printed" << endl;
    }
    else{
      cout << "But this should!" << endl;
    }
    return 0;
  }
#+end_src

You also don't have to ask just one question at a time. You can combine questions with =&&=, pronounced "and", and =||=, pronounced "or".

If I have questions a and b then =a && b= only returns =true= if *both* =a= and =b= are true. Similarly, =a || b= returns true if =a= is true, if =b= is true, or if both of them are true.

**** The dirty truth about booleans in C++
 Beware, absolute nastiness awaits you in this section. You'll learn about horrendous, semantics breaking, decisions in the history of programming language design.

 So, you see dear reader, it turns out that 
 
 #+begin_src cpp :tangle codesnips/truth2.cpp
   #include <iostream>
   using namespace std;

   int main(){
     if(true == 1){
       cout << "true is the same as 1" << endl;
     }

     if(false == 0){
       cout << "false is the same as 0" << endl;
     }

     int num = 1;
     if(true == num){
       cout << "true is 1 even if we insist that the 1 is an int" << endl;
     }
   }
 #+end_src

Compile this code and run it to confirm the horrible truth, but you'll see that booleans are really just numbers. Which is honestly a terrible decision because it means there's all sorts of wrong things that can happen.

#+begin_src cpp :tangle codesnips/truth3.cpp
  #include <iostream>
  using namespace std;

  int main(){
    int num;
    cout << "Enter a number, promise I won't misuse it" << endl;
    cin >> num;
    if(num){ // whoops I meant to compare this to something but I got distracted by a dog
      cout << "This means that num is greater than 3" << endl;
      cout << "See? " << num << endl;
    }
    else{
      cout << "num is too small" << endl;
    }
    return false; // what is happening here
  }
#+end_src

Look at this wretched code! =return false=? =if(num)=? This is terrible! And the compiler did /nothing/ to stop it!

Woe be upon us!
**** TODO An authentication quiz
META: Fix this to be an example of a personality quiz instead because that's a project I like to give early on

Okay, let's do something silly as an example of putting some of these concepts together. A little program that runs a very special security quiz that asks you a few questions, use some variables, and then print out the results. This will determine, in a foolproof way, if the person answering the questions is definitely me.

#+begin_src cpp :tangle codesnips/securityQuiz.cpp
  #include <iostream>
  using namespace std;

  int main(){
    string q1 = "Have you ever touched a computer before? type 1 or 0\n";
    bool a1;
    string q2 = "Do you prefer whiteboards to blackboards ? type 1 or 0\n";
    bool a2;
    string q3 = "False? type 1 or 0\n";
    bool a3;
    string q4 = "Is a proof a program? type 1 or 0\n";
    bool a4;

    cout << q1;
    cin >> a1;
    cout << q2;
    cin >> a2;
    cout << q3;
    cin >> a3;
    cout << q4;
    cin >> a4;

    if((a1 && !a2 && a3) || a4){
      cout << "Oh, hi me, it's definitely you I'm talking to because no one could crack that code" << endl;
    }
    else{
      cout << "You're not left_adjoint!" << endl;
    }
    return 0;
  }
#+end_src
Can you figure out what to enter to hack the system?
*** Exercises  
1. *Basic*: Check if a number is positive, negative, or zero and print an appropriate message.
2. *Intermediate*: Create a simple grade calculator that takes a numeric score and outputs a letter grade (90+=A, 80+=B, 70+=C, 60+=D, <60=F).
3. *Challenge*: Build an eligibility checker that asks for age and tells the user what they can legally do (vote at 18, drink at 21, rent a car at 25, run for president at 35).
*** TODO Letting the compiler figure out the type
 There's a fun trick you can do in C++: not even bother writing the type and, instead, just letting the compiler figure out---in the process of compiling---what the type is supposed to be for you! We can do that with the `auto` keyword.

 So we can actually do things like:
 #+begin_src cpp :tangle codesnips/auto1.cpp
   #include <iostream>
   using namespace std;

   int main(){
     auto x = 5;
     auto y = 10;

     cout << "we can add two numbers whose types we didn't name! So x + y is..." << x+y << endl;
     return 0;
     
   }
 #+end_src

*** DONE Data formatting [2/2]
Now we get to a useful, but perhaps slightly tedious, set of skills to learn: how to properly format your output.

Note that all of the following examples mean you also need to include the library =<iomanip>= as well by adding the line =#include <iomanip>= into your code.

**** DONE Making a table
So if we wanted to make a table in C++ we might want to do something like use some '|' as dividers like this. For this and the rest of the examples in this table I'm going to assume that we're making a table that shows information about pets: their name, species, and how old they are. If we try this in the naive way we'll try something like this:
#+begin_src cpp :tangle codesnips/petTable1.cpp
  #include <iostream>
  using namespace std;

  int main(){
    cout << "|" << "Pet name"
         << "|" << "Pet species"
         << "|" << "Pet age"
         << "|" << endl;

    cout << "|" << "Liese"
         << "|" << "Cat"
         << "|" << "24"
         << "|" << endl;

    cout << "|" << "Dora"
         << "|" << "Dachshund"
         << "|" << "15"
         << "|" << endl;

    return 0;
  }
#+end_src

Now if you try running this code you'll discover that it looks, well, *terrible*. Everything is badly misaligned. Okay, so what we need is the ability to control the spacing: to set a /width/ to the a field and let the text comfortably inside that space. Thankfully, C++ already has a function to do that: =setw=, which stands for "set width". The =setw= function takes one argument, an =int=, and sets aside that much space for the next piece of text you pass to =cout=.

We can test it out by modifying our program like this:
#+begin_src cpp :tangle codesnips/columns1.cpp
  #include <iostream>
  #include <iomanip>
  using namespace std;

  int main(){
    cout << "|" << setw(15) << "Pet name"
         << "|" << setw(15) << "Pet species"
         << "|" << setw(15) << "Pet age"
         << "|" << endl;

    cout << "|" << setw(15) << "Liese"
         << "|" << setw(15) << "Cat"
         << "|" << setw(15) << "24"
         << "|" << endl;

    cout << "|" << setw(15) << "Dora"
         << "|" << setw(15) << "Dachshund"
         << "|" << setw(15) << "15"
         << "|" << endl;

    return 0;
  }
#+end_src

Exercise:
#+begin_quote
So what we've left implicit so far is that a call to =setw= will modify the /next/ thing. Try out, for yourself, what happens if you put it in front of the "|" instead.
#+end_quote

This is /alright/ but personally I think the way the data and columns are aligned like this makes it feel hard to skim. I think it looks better to have the column names aligned the /opposite/ way to the data. So C++ has an easy way of doing this: =cout << left= will make data left-aligned and =cout << right= will make the data right-aligned. Once you set an alignment it stays that way until you change it again. So we need to do something like this
#+begin_src cpp :tangle codesnips/columns2.cpp
  #include <iostream>
  #include <iomanip>
  using namespace std;

  int main(){
    cout << left;
    cout << "|" << setw(15) << "Pet name"
         << "|" << setw(15) << "Pet species"
         << "|" << setw(15) << "Pet age"
         << "|" << endl;
    cout << right;

    cout << "|" << setw(15) << "Liese"
         << "|" << setw(15) << "Cat"
         << "|" << setw(15) << "24"
         << "|" << endl;

    cout << "|" << setw(15) << "Dora"
         << "|" << setw(15) << "Dachshund"
         << "|" << setw(15) << "15"
         << "|" << endl;

    return 0;
  }
#+end_src
That's slightly easier to read, but we still have room to fuss around with this program. Rather than playing with the alignment of the column names let's try adding a visible divider. To do that we can play with =setfill=, another function that lets us replace the spaces in the padding created by =setw= with any character we want.

#+begin_src cpp :tangle codesnips/columns3.cpp
  #include <iostream>
  #include <iomanip>
  using namespace std;

  int main(){

    cout << "|" << setw(15) << "Pet name"
         << "|" << setw(15) << "Pet species"
         << "|" << setw(15) << "Pet age"
         << "|" << endl;

    cout << setfill('-');
    cout << "|" << setw(15) << ""
         << "|" << setw(15) << ""
         << "|" << setw(15) << ""
         << "|" << endl;
    cout << setfill(' ');
  
  
    cout << "|" << setw(15) << "Liese"
         << "|" << setw(15) << "Cat"
         << "|" << setw(15) << "24"
         << "|" << endl;

    cout << "|" << setw(15) << "Dora"
         << "|" << setw(15) << "Dachshund"
         << "|" << setw(15) << "15"
         << "|" << endl;
  
    return 0;
  }

#+end_src

**** DONE Formatting decimal points
Okay the other formatting topic that we need to deal with is how to deal with decimal points. Let's look at a simple program with doubles and you can immediately see the formatting problem:

#+begin_src cpp :tangle codesnips/badmoney.cpp
  #include <iostream>
  using namespace std;

  int main(){

    double cost = 100;

    cout << "Calculating tax (33%) on your bill: $" << cost / 3 << endl;

    return 0;
  }
#+end_src

it prints out that the tax is $33.3333. Well that's not how we write cents! We actually only want to include two decimal points. We can do that with =cout << setprecision(2)= so our code becomes
#+begin_src cpp :tangle codesnips/money1.cpp
  #include <iostream>
  #include <iomanip>
  using namespace std;

  int main(){
  
    double cost = 100;

    cout << setprecision(2);
  
    cout << "Calculating tax (33%) on your bill: $" << cost / 3 << endl;
  
    return 0;
  }

#+end_src
Wait, shoot, no that's still not right. Okay so the problem here is that =setprecision(2)= is going to keep "two digits" so if your number ends up being 0.3333 it will print as 0.33. If it's 33.3333 it will print as 33. That's not /really/ what we want.

So we need to /also/ do =cout << fixed;= in order to make sure it /always/ prints exactly two things to the right of the decimal, all the time.

#+begin_src cpp :tangle codesnips/money2.cpp
  #include <iostream>
  #include <iomanip>
  using namespace std;

  int main(){

    double cost = 100;

    cout << setprecision(2);
    cout << fixed;

    cout << "Calculating tax (33%) on your bill: $" << cost / 3 << endl;

    return 0;
  }

#+end_src
*** Exercises
1. *Basic*: Create a receipt with 3 items showing item name, price, and quantity in aligned columns.
2. *Intermediate*: Display a multiplication table (1-10) with proper alignment and borders.
3. *Challenge*: Create a formatted invoice that includes items, quantities, unit prices, line totals, subtotal, tax (8.5%), and grand total - all properly aligned and formatted.

**** TODO Abstracting formatting with functions
*** DONE Your first while loop: a number guessing game
In this section we'll be covering how to do your first kind of loop in C++, the =while= loop. Conceptually, a =while= loop lets you do something over and over again until the question "should I keep going" returns false.

So, let's take the smallest silliest example we can to show the syntax: a program that keeps running and asking you to enter a number until you enter =0=.
#+begin_src cpp :tangle codesnips/firstWhile.cpp
  #include <iostream>
  using namespace std;

  int main(){
    // so if we're going to read in a number it needs
    // a place to be stored, which means that we need to create a variable.
    // we want to be in control of what is stored in the variable before our first run of the
    // loop, so we set it to -1 to start.
    int guessed = -1; 

    // how do we ask the question "keep going until the variable guessed is 0"? Well, you need
    // to mentally invert this and say "while the variable is NOT 0, run the loop"
    while(guessed != 0){ // like every other part of c++ where you have a chunk of code that runs, you put it inside {}
      // now we ask for our number
      cout << "What's the magic number?" << endl;
      cin >> guessed;
    }

    cout << "You're right! It was 0!" << endl;
    return 0;
  }
#+end_src
*** Exercises
1. *Basic*: Write a countdown program that asks for a starting number and counts down to 0.
2. *Intermediate*: Create a password checker that keeps asking until the user enters "quit" or the correct password (you choose it).
3. *Challenge*: Implement a simple calculator that keeps performing operations until the user enters 0 for both numbers.
*** TODO A randomized guessing game
So a guessing game where the number is the same every time isn't very interesting. What we really want is the ability to have the program choose a new number "randomly"[fn:9] and then ask you to guess. Of course, it'd be a pretty unfair game if it didn't at least give you a hint so this program will also tell you whether to guess higher or lower.

So first, here's a really simple example of how to generate random numbers in C++. Note that we also have to include a thing thing at the top of the file: =#include <cstdlib>=, because that's where the functions we need for random numbers live. 

#+begin_src cpp :tangle codesnips/badrand.cpp
  #include <iostream>
  #include <cstdlib>
  using namespace std;

  int main(){
    int num = rand();

    cout << "Our number is: " << num << endl;
    return 0;
  }
#+end_src

Now, if I run this I get
#+begin_example
Our number is: 1804289383
#+end_example
Okay, that's a really huge number and not really what we want but we'll deal with that in a second. It's definitely not a number I expected so that's good! Let me try running it again and---
#+begin_example
Our number is: 1804289383
#+end_example
Oh, huh, that's weird. Let's try again and
#+begin_example
Our number is: 1804289383
#+end_example

So what's going on here? Yes it's a "random" number but it's the same "random" number every time. It might be illuminating to try the following:

#+begin_src cpp :tangle codesnips/badrand2.cpp
  #include <iostream>
  #include <cstdlib>
  using namespace std;

  int main(){
    cout << "Let's try to print out a bunch of random numbers" << endl;
    cout << rand() << endl;
    cout << rand() << endl;
    cout << rand() << endl;
    cout << rand() << endl;
    cout << rand() << endl;
    return 0;
  }
#+end_src

And now I get an output of
#+begin_example
Let's try to print out a bunch of random numbers
1804289383
846930886
1681692777
1714636915
1957747793
#+end_example
So each time we use =rand()= it is giving a different number but each time we run the program it's the same sequence of random numbers. This is where we need to explain seeds.

Seeds are what makes pseudo-random[fn:9] number generation so different than actual randomness. Computers can't /really/ do true randomness, but they can fake it well by performing a series of calculations where the output looks random unless you know the very first input that starts the calculations. This very first input is the "seed" for the random number generator.

For a given seed, =rand= will always produce the same sequence of outputs. The trick, then, is that we need to choose a different seed every time we run the program. The traditional choice is to use another function called =time=. If you write =time(0)= what you'll get back is the number of seconds since midnight January 1st 1970. Since this is a number that will be different every time you run the program, it will be a good choice of different seeds for every time we run our code.[fn:10]

Let's test this out quick
#+begin_src cpp :tangle codesnips/betterrand.cpp
  #include <iostream>
  #include <cstdlib>
  using namespace std;

  int main(){
    srand(time(0));
  
    cout << "Let's try to print out a bunch of random numbers" << endl;
    cout << rand() << endl;
    cout << rand() << endl;
    cout << rand() << endl;
    cout << rand() << endl;
    cout << rand() << endl;
    return 0;
  }

#+end_src

Now we're finally ready to write our number guessing game
#+begin_src cpp :tangle codesnips/guessy.cpp
  #include <iostream>
  #include <cstdlib>

  using namespace std;

  int main(){
    // we make a variable for our guess
    int guess = -1;
    // we set the seed for our secret number
    srand(time(0));
    // we set our secret number, we use the % function to scale rand() to 0-99 and then add 1 to make
    // the range 1-100
    int secret = rand() % 100 + 1;

    while(guess != secret){
      cout << "What do you think the number is?" << endl;
      cin >> guess;
      if(guess > secret){
        cout << "lower!" << endl;
      }
      else if(guess < secret){
        cout << "higher!" << endl;
      }
    }

    cout << "You guessed it!" << endl;
    return 0;
  }
#+end_src

Try to read this code through and understand the logic of what it's doing! The only thing we haven't explained to this point is the =%= operator, which is the "modulus" operator. Basically, =a % b= returns the remainder---in the "you're learning division as a kid" sense of remainder---of dividing =a= by =b=. Now, in terms of why we *care* about this operator it gives us a quick way to take a big range of numbers and map it to something smaller. For example, if we do =a % 20= our outputs, no matter what =a= is, will be between 0 and 19. Similarly if we say =a % 100= this will give us an output that's between 0 and 99.
*** Exercises
1. *Basic*: Simulate rolling two six-sided dice and display their individual values and sum.
2. *Intermediate*: Create a "Rock, Paper, Scissors" game where the computer randomly chooses and you play one round.
3. *Challenge*: Simulate flipping a coin 1000 times and report the percentage of heads vs tails. Bonus: Allow the user to specify the number of flips.
**** TODO Adding a limited number of guesses
*** DONE Averaging numbers and while-loops
Here's another idiom that will help us get practice with while-loops: how do you average an *arbitrary* number of numbers?

So this is a fun exercise because it means we need to keep track of how many things have been entered and then divide by that at the end. So I'm going to just assume we're adding up =double= s here because it makes everything fundamentally similar. How does one quit out of this loop? Well there's two ways we could do this. One is to have a special number that means "we're done". Something like "-1". That's the approach we're going to do first. After that, we'll see how to  

Our steps are
 1. Ask for a number, if that number is =-1= then stop asking and go to the end
 2. If it's *not* =-1= then you need to increment a variable that counts how many numbers you've read in and also add the number that was read in to the total
 3. When you get to the end of the program go ahead and divide the total by the number of things added together to get the average

We're going to do the simplest version like this:
#+begin_src cpp :tangle codesnips/whileAverage.cpp
  #include <iostream>
  using namespace std;

  int main(){
    int numItems = 0;
    double sum = 0;
    double numEntered = 0;

    cout << "Enter a number greater or equal to 0: ";
    cin >> numEntered;
    while(numEntered >= 0){
      numItems = numItems + 1;
      sum = sum + numEntered;
      cout << "Enter a number greater or equal to 0: ";
      cin >> numEntered;
    }

    cout << "The average of the numbers you entered is: " << sum / numItems << endl;
  }
#+end_src

Okay, so there's still a problem with our code: do you see it? If you don't I'll give you a hint: what happens if you don't enter *any* valid numbers at all?

That's right! You're dividing by zero! So instead we want to, at the end, replace our final =cout= with an if-statement that checks to make sure you didn't enter nothing at all:

#+begin_src cpp :tangle codesnips/whileAverag2.cpp
  #include <iostream>
  using namespace std;

  int main(){
    int numItems = 0;
    double sum = 0;
    double numEntered = 0;
  
    cout << "Enter a number greater or equal to 0: ";
    cin >> numEntered;
    while(numEntered >= 0){
      numItems = numItems + 1;
      sum = sum + numEntered;
      cout << "Enter a number greater or equal to 0: ";
      cin >> numEntered;
    }
  
    if(numItems >0){
      cout << "The average of the numbers you entered is: " << sum / numItems << endl;
    }
    else{
      cout << "Did you change your mind?" << endl;
    }
  }
#+end_src

Now you can see that we've safeguarded against dividing by zero!
*** Exercises
1. *Basic*: Calculate the average of exactly 5 test scores entered by the user.
2. *Intermediate*: Find the minimum, maximum, and average of numbers entered (stop on -1).
3. *Challenge*: Calculate a weighted average where the user enters value-weight pairs. Stop when weight is 0. Example: test1=85, weight=0.3; test2=90, weight=0.7; weighted average = 88.5.

** TODO For-loops (and the shape of loops to come)[fn:8] [1/2]
So far we've seen some examples of using =while= loops and now it's time to see the other kind of loop: the =for=-loop. Unlike =while=, which is "indefinite" iteration because it could theoretically go on forever, the =for=-loop is "definite" iteration because it should (unless there's a bug) only run for a pre-determined number of times.

If =while= can be thought of us "keep going until something changes", then =for= should be thought of as "do this X times".

The simplest possible for-statement we can write looks like
#+begin_src cpp :tangle codesnips/for1.cpp
  #include <iostream>
  using namespace std;

  int main(){
    for(int i=0; i < 20; i = i +1){
      cout << "We're on the " << i  << "th loop" << endl;
    }
    
    return 0;
  }

#+end_src

Okay so let's break down the syntax of this a bit because it's more complicated than the syntax of a =while= loop:
you start with =for=, then the next part declares a whole number (=int=) valued counter that you can use inside the loop. Then you after the =;= you have the condition for when the loop continues: in this case the loop should continue as long as the variable =i= is less than 20. Then the last bit is what happens to the counter at the end of the next loop, which in this case says "increase =i= by 1". In fact, there's a special operator =i++= that just means =i =i+1= so in the future we'll use that.

Another thing you might have noticed is that we're starting to count /from/ 0 and /going up to/ 19. How many times does that mean the loop is executing in total? The answer is 20! Count it yourself if that doesn't feel intuitive.

Let's make another loop quick but this time I want you to write out, for yourself, what it should print out before you even compile and run it.

#+begin_src cpp :tangle codesnips/for2.cpp
  #include <iostream>
  using namespace std;

  int main(){
    for(int i=0; i < 5; i++){
      cout << "The " << i << "th number squared is: " << i*i << endl;
    }
  
    return 0;
  }
#+end_src

#+begin_quote
Exercise: Change this loop so that it instead runs from 1 through 5 rather than 0 through 4. You /could/ do this by changing the =cout= statement but I want you to change the for-loop setup itself.
#+end_quote

Now you don't /just/ have to count up by one, even though that's probably the most common use for reasons we'll see in a couple of sections from now.

You can count down like this:
#+begin_src cpp :tangle codesnips/for3.cpp
  #include <iostream>
  using namespace std;

  int main(){
    for(int i=4; i >= 0; i = i - 1){
      cout << "The " << i << "th number squared is: " << i*i << endl;
    }

    return 0;
  }

#+end_src

#+begin_quote
Exercise: Try making a for-loop that prints out only even numbers. Again, you could do this by changing the =cout= statement but I want you to change the for-loop itself.
#+end_quote

*** DONE Summing a bunch of numbers
Here's an example of another common idiom in programming: you use a for-loop to /accumulate/ results of a calculation.

So here's how to add a bunch of numbers together:
#+begin_src cpp :tangle codesnips/forSum.cpp
  #include <iostream>
  using namespace std;

  int main(){

    int sum = 0;

    for(int i=0; i < 10; i++){
      sum = sum + i;
    }

    cout << "The sum is: " << sum << endl;
    return 0;
  }
#+end_src

Note that what we've done is create a new variable, =sum=, in order to hold the sum of all the numbers from 0 through 9 and each step of the for-loop we add =i= to =sum=. The formula for this is, in general, =n*(n+1)/2= and we can see that running this code prints 45, which is exactly what we'd expect from this formula. Change the numbers a few times in the limits of the for-loop and check that it stays fitting this formula.

#+begin_quote
Exercise: Change this so that it sums the /squares/ of 0 - 9.
#+end_quote
*** Exercises
1. *Basic*: Print the first 20 Fibonacci numbers using a for-loop.
2. *Intermediate*: Draw a triangle pattern with asterisks. Ask the user for height. Example for height=5:
   #+begin_example
   *
   **
   ***
   ****
   *****
   #+end_example
3. *Challenge*: Print all prime numbers between 1 and 100. Hint: For each number, check if it's divisible by any number from 2 to its square root.
*** TODO (Advanced) Arrays: the reasons for =for=
Here's a more advanced topic that you'll be needing not just for this class but for the rest of your classes where you're doing C++: arrays.

We're covering arrays here because they are, in a sense, the reason for using =for= loops. If, in the previous sections, you felt like "okay so a =for= is like a while, but more restricted?" that impression isn't /wrong/ per se. =while= is the more general concept that lets us do all sorts of things but =for= is best when you're dealing with finite collections of /stuff/.

What we haven't shown you yet is what "a finite collection of stuff" looks like!

Here's an example and we'll talk it through
#+begin_src cpp :tangle codesnips/array1.cpp
  #include <iostream>
  using namespace std;

  int main(){

  
    int numberArray[10]; // this is how you declare an array
    // this declares the array with ten "boxes" for ints in it
    // the boxes are all labeled from 0 - 9

    // now we're going to use a for-loop in order to try
    // and put things in the boxes

    for(int i=0; i<10; i++){
      numberArray[i] = i*i;
    }
    // we're putting i^2 in the ith slot

    // to use an array slot once it's filled it's, again, just
    // like a variable with a special name
    for(int i=0; i<10; i++){
      cout << numberArray[i] << endl;
    }
  
    return 0;
  }
#+end_src

If you run this it will first fill the array with values, putting 0 in the =numberArray[0]= slot, 1 in the =numberArray[1]= slot, 4 in the =numberArray[2]= slot, &c.

This really is like having a really special variable that has a numerical index---a number in the name. When you declare an array of size =n= C++ sets aside the amount of memory to hold =n= things of that type. You can make arrays of any type (including other arrays, as we'll see shortly).

So arrays get really useful when trying to represent things like rows in a table. Each array is going to represent a different column and an index is going to represent a row.

An example program would be something like this:
#+begin_src cpp :tangle codesnips/arrayPets.cpp
  #include <iostream>
  using namespace std;

  int main(){
    int numPets = 5;
  
    string petNames[numPets];
    string petSpecies[numPets];

    for(int i=0; i < numPets; i++){
      cout << "Enter the name of the pet: ";
      cin >> petNames[i];
      cout << "Enter the pet species: ";
      cin >> petSpecies[i];
    }

    for(int i=0; i < numPets; i++){
      cout << petNames[i] << " is a " << petSpecies[i] << endl;
    }
  
    return 0;
  }
#+end_src
So line by line what this program does is:
1. make a variable to hold the number of pets in the pet-information table, so that we can change it in just one place
2. two arrays for the names of pets and the species of pet
3. a for-loop that asks for the information for each row of the table and fills it in
4. a for loop that prints out each row


#+begin_quote
Exercise: Take this program and add another column for the age of the pet

That means you'll need to add a new array of ints to hold the age, ask for the age with cin, and also print that out appropriately.
#+end_quote
*** Exercises
1. *Basic*: Create an array of 7 daily temperatures and find the warmest and coldest days.
2. *Intermediate*: Reverse the contents of an array in-place (without creating a new array).
3. *Challenge*: Implement a simple grade book that stores 5 students with 3 test scores each. Calculate and display each student's average.
**** TODO What happens if you access outside the bounds of an array?
There's one last topic we need to address: what happens if you access outside the bounds of the array? Now in many programming languages this will end in an *error*. For example, if you run the following Python program it will crash which is *a good thing*.

#+begin_src python :tangle codesnips/badArray.py
  arr = [1,2,3,4]

  print(arr[10])
#+end_src

Now let's try a similar thing in C++:
#+begin_src cpp :tangle codesnips/badArray.cpp
  #include <iostream>
  using namespace std;

  int main(){
    int arr[5] = {0,1,2,3,4}; // this is how we initialize an array, for the record, but it's only practical for really small arrays

    cout << arr[10] << endl;

    return 0;
  }
#+end_src

Well when I ran this I got =1663205712= printed out to the console. If you remember from way at the beginning of this tutorial when we went over what happens when you use an uninitialized variable, you might see a similarity! Except that, in some ways, this is worse!

** TODO Data validation, the world's most annoying idiom [1/2]
So we've been playing fast and loose for awhile about how to read in data from the user. But, in reality, you should be checking what the user has entered and asking them to re-enter their response if it's not something you expect. This is actually a really annoying topic because there's no easy way to do this in base C++, which is why I'm going to introduce this topic early. 

Here's two scenarios:
 + The user enters an option that is the right kind of data but that you didn't expect and you need to ask again
 + The user enters an option that is the *wrong* kind of data, which means that =cin= is going to have a hiccup

*** DONE Right kind of data, but wrong option
So what we mean here is something like you asking for "yes" or "no" from the user and they, in their infinite snarkiness, enter "chicken". You will not let this chicken stand and, instead, will stop and make them answer again until they give a response that's useful. This is the easier scenario and we can solve the problem with a simple while-loop like this

#+begin_src cpp :tangle codesnips/validation1.cpp
  #include <iostream>
  using namespace std;

  int main(){
    // we need to make a space for storing the input
    string opt = "";

    //we have our "asking" loop
    //we're asking the questions while it is NOT "yes" and it is NOT "no" and it is NOT "y" and it is NOT "n"
    //or, in a way that's maybe closer to how we say it in English it's
    // NOT (yes or no or y or n)
    while(! (opt == "yes" || opt == "no" || opt == "y" || opt == "n")){
      cout << "Enter a valid option (yes/no/y/n): ";
      cin >> opt;
    }

    cout << "You chose: " << opt << endl;
  }
#+end_src
*** Exercises
1. *Basic*: Create a menu system that only accepts options 1-5, rejecting anything else.
2. *Intermediate*: Validate email format - must contain exactly one @ and at least one . after the @.
3. *Challenge*: Create a date validator that checks valid month (1-12) and appropriate days for each month (including leap years for February).
*** TODO The wrong kind of data (cin.fail() &c.) [0/2]
Okay so from here we have some interesting issues that come down to exactly *what* =cin= and =>>= are doing together.
**** TODO What ever happened to baby cin?
First off, consider the following program.

#+begin_src cpp :tangle codesnips/badcin1.cpp
  #include <iostream>
  using namespace std;

  int main(){
    int num1;
    int num2;

    cout << "Enter two numbers" << endl;
    cin >> num1;
    cin >> num2;

    cout << "The sum of these numbers was: " << num1 + num2 << endl;
    return 0;
  }
#+end_src

Now if I run this program and enter input like this
#+begin_example
1[hit the enter key]
2[hit the enter key]
#+end_example

You'll see "The sum of these numbers was: 3" printed out.

If I enter
#+begin_example
1 2[hit the enter key]
#+end_example

I'll *also* see "The sum of these numbers was: 3" printed out. Why is that? Okay, so it has to do with the way =>>= works. Think of =cin= as being like a kind of pipeline. We fill it with stuff by typing a bunch of things and then hitting the enter key. Now =>>= doesn't just empty out everything in the pipe at once. It goes until either there's an error or until it hits whitespace (like, well, a space). So in the second example you've put "1 2" in the pipeline and the first call to =>>= will grab the =1= from the pipeline then *stop*. Then the second call to =>>= will grab the =2= from the pipeline then *stop*.

Now with that behavior in mind, we can start talking about what happens if you enter something that is the wrong type.

Let's run the program above one more time but now with the following input
#+begin_example
1 dog[hit the enter key]
#+end_example
What you'll get printed out is "The sum of these numbers was: 1". Why? Because it failed to read a number into =num2= and, so, just gave it a value of 0 rather than stop the program and fail.[fn:11]

We're going to introduce a new function called =cin.fail()= that lets us ask the question "did the last time we tried to read from =cin= go wrong?"

So now in the following program we'll ask for two numbers and, then, if there's a failure we'll print out "hey, buddy, that's not cool" rather than print the sum of the numbers

#+begin_src cpp :tangle codesnips/badcin2.cpp
  #include <iostream>
  using namespace std;

  int main(){

    int num1;
    int num2;

    cout << "Enter two numbers" << endl;
    cin >> num1;
    cin >> num2;

    if(cin.fail()){
      cout << "Hey, buddy, that's not cool" << endl;
    }
    else{
      cout << "The sum of these numbers was: " << num1 + num2 << endl;
    }

    return 0;
  }
#+end_src

Run this and test it out and you'll find that if you write something that can't be read as a number then it'll print out "Hey, buddy, that's not cool" rather than print out a badly formed sum. 

Okay so we can /avoid/ running our program if something has gone wrong but we also want to potentially ask for new input over and over until correct data is entered.
**** TODO Recovering from an error
So this next part is another application of our old friend the /while/ loop.


We'll start with the obvious thing to do from the pieces we've seen so far (and spoiler this code isn't going to work)
#+begin_src cpp :tangle codesnips/cinfail1.cpp
  #include <iostream>
  using namespace std;

  int main(){
    int num1;

    cout << "Enter a number" << endl;
    cin >> num1;

    while(cin.fail()){
      cout << "No, buddy, enter a *number*: " << endl;
      cin >> num1;
    }

    return 0;
  }
#+end_src

So /why/ doesn't this work? You'll see that it leads to an infinite loop of printing "No, buddy, enter a *number*" after just one bad input. So the behavior of =cin= is that once it sees a single error it gets into a state of not accepting any more input until it gets fixed. You can do that by calling a function =cin.clear()=. We're not done yet, though, because if you remember the "pipeline" analogy for how =cin= works we haven't actually gotten rid of what's in the pipeline that was causing the error. In order to throw it away we need to write =cin.ignore(256,'\n')=. So putting this all together we've got

#+begin_src cpp :tangle codesnips/cinfail2.cpp
  #include <iostream>
  using namespace std;

  int main(){
    int num1;

    cout << "Enter a number" << endl;
    cin >> num1;

    while(cin.fail()){
      cout << "No, buddy, enter a *number*: " << endl;
      cin.clear();
      cin.ignore(256,'\n');
      cin >> num1;
    }

    return 0;
  }
#+end_src
* TODO More advanced programs [1/3]
** TODO Functions on strings
*** DONE Simple operations on strings
So there's a few things you can do with strings. The first, is the ability to glue strings together, also called "concatentation". So far we've been implicitly gluing strings together using the syntax of =cout= and =<<=, but you can *actually* stick two strings to each other with =+=, just like adding two numbers.

Like this program:
#+begin_src cpp :tangle codesnips/stringConcat.cpp
  #include <iostream>
  using namespace std;

  int main(){

    string str1;
    string str2;

    cout << "Enter some things: ";
    cin >> str1;
    cin >> str2;

    cout << "Okay gluing those together you said: " << str1 + str2 << endl;
  
    return 0;
  }
#+end_src

This is an example of something kinda neat in C++, called "operator overloading". Basically, you can reuse things like  =<<= and =+= in all sorts of different contexts at different *types*. That's the key part. The different uses have to be for different types or else there will be confusion. =+= can mean something for two ints, for an int and a string (check that one out yourself, by the way), for two strings, for two doubles, &c. But it can't mean two different things if you're just writing =1 + 2= where 1 and 2 are both ints.

Okay, also we should talk about how to turn data into strings because this is going to be useful! Basically, there's just a function in the =<string>= library that you can use called =to_string= that will convert any other data to being a string. This works with basically everything, like in this program:

#+begin_src cpp :tangle codesnips/toString.cpp 
  #include <iostream>
  #include <string>
  using namespace std;

  int main(){
    int num1 = 1;
    bool b = true;
    char c = 'd';
    double d = 1.23456;

    cout << to_string(num1) + to_string(b) + to_string(c) + to_string(d) << endl;
    return 0;
  }
#+end_src
*** Exercises
1. *Basic*: Count the number of vowels (a, e, i, o, u) in a string entered by the user.
2. *Intermediate*: Check if a string is a palindrome (reads the same forwards and backwards).
3. *Challenge*: Create a word censoring program that replaces specified "bad words" with asterisks of the same length.
*** TODO =find= and =substr=
Okay, so now let's talk about some convenience functions that help us take apart and manipulate strings. The first is the ability to /find/ an occurence of one string inside another:

#+begin_src cpp :tangle codesnips/find1.cpp
  #include <iostream>
  #include <string>
  using namespace std;

  int main(){

    string str1 = "this is a rock";
    string str2 = "rock";

    // let's see what find does
    cout << str1.find(str2) << endl;
    return 0;
  }
#+end_src

*** TODO Iterating over strings with for-loops
Now remember how I showed you a bit about how arrays work and the fact that for-loops were made to work with them? Okay, so part of why I needed to show you that is while *technically* you're not using arrays in this class it's useful to understand the idea behind them because you can treat strings "like"[fn:13] arrays for operating on them.

The general idiom is that you can get the length of the string like this =s.length()= for a string =s=, then you can put that as the bounds of the for-loop and you can use array syntax (e.g. the square brackets) in order access the characters inside the string one by one.

Okay so here's a wholeLower function that turns an entire string to lower case using the per-character function =tolower()=:

#+begin_src cpp :tangle codesnips/wholeLower.cpp
  #include <iostream>
  #include <string>
  using namespace std;

  string wholeLower(string s){

    for(int i = 0; i < s.length(); i++){
      s[i] = tolower(s[i]);
    }
  
    return s;
  }

  int main(){
    string str = "YELLING";

    cout << wholeLower(str) << endl;
  }
#+end_src

*** TODO Example: Sarcasm Case
 Alright, here's a nice silly example for how we use for-loops with strings:
#+begin_src cpp :tangle codesnips/sarcasm.cpp
  #include <iostream>
  #include <string>
  #include <cstdlib>
  using namespace std;

  string sarcasmCase(string s){
    string s2 = s;
    for(int i = 0; i < s2.length(); i++){
      if(rand() % 2 == 0){
        s2[i] = tolower(s[i]);
      }
      else{
        s2[i] = toupper(s[i]);
      }
    }
    return s2;
  }

  int main(){
    srand(time(0));
    string str = "you can't do that!";

    cout << sarcasmCase(str) << endl;
  }
#+end_src
*** Exercises
1. *Basic*: Convert a string to alternating caps (LiKe ThIs) for every character.
2. *Intermediate*: Count the frequency of each word in a sentence (case-insensitive).
3. *Challenge*: Implement a Caesar cipher that shifts letters by a user-specified amount. Handle wrapping (z+1 = a) and preserve case.

** DONE Switches vs. ifs
Switch statements are actually pretty simple and can, essentially, be thought of as "compiling" down to a more verbose if-elseif-else statement, except that rather than being able to ask *any* question you're just asking the question is /this/ equal to /this/.

Okay, concrete example time:
#+begin_src cpp :tangle codesnips/switch1.cpp
  #include <iostream>
  #include <string>
  using namespace std;

  int main(){

    char letter;
    cout << "Enter a letter and I'll tell you the name of a dog that starts with that: ";
    cin >> letter;
  
    switch(tolower(letter)){
      case 'b':
        cout << "Bertie" << endl;
        break;
      case 'c':
        cout << "Charles" << endl;
        break;
      case 'd':
        cout << "Dora" << endl;
        break;
      case 'e':
        cout << "Edie" << endl;
        break;
      case 'f':
        cout << "Francine" << endl;
        break;
      case 't':
        cout << "Taffy" << endl;
        break;
      case 'p':
        cout << "Pisces" << endl;
        break;
      default:
        cout << "Sorry, I don't know any dog names that start with that" << endl;
    }

    return 0;
  }
#+end_src

So what this code is doing is equivalent to the following program
#+begin_src cpp :tangle codesnips/switchIf.cpp
  #include <iostream>
  #include <string>
  using namespace std;

  int main(){
    char letter;
    cout << "Enter a letter and I'll tell you the name of a dog that starts with that: ";
    cin >> letter;

    if(tolower(letter) == 'b'){
      cout << "Bertie" << endl;
    }
    else if(tolower(letter) == 'c'){
      cout << "Charles" << endl;
    }
    else if(tolower(letter) == 'd'){
      cout << "Dora" << endl;
    }
    else if(tolower(letter) == 'e'){
      cout << "Edie" << endl;
    }
    else if(tolower(letter) == 'f'){
      cout << "Francine" << endl;
    }
    else if(tolower(letter) == 't'){
      cout << "Taffy" << endl;
    }
    else if(tolower(letter) == 'p'){
      cout << "Pisces" << endl;
    }
    else {
      cout << "Sorry, I don't know any dog names that start with that" << endl;
    }

    return 0;
  }
#+end_src

So you can see some of the differences between if and switch. First, note that you only have to provide the expression you're comparing *once* to the switch statement. Meanwhile the direct equivalent would involve having to run =tolower= on the letter every time.

Now that just seems inconvenient here but there are times that it's actually a big deal! Let's consider this example with random numbers

#+begin_src cpp :tangle codesnips/diceRoll.cpp
  #include <iostream>
  #include <cstdlib>
  using namespace std;

  int main(){
    // here we set the starting seed for the random number generator
    srand(time(0));

    // here we're playing a game where on a 1 you super win
    // on a 2 or 6 you lose
    // on a 3,4,5 you win a little bit
    // we're going to use a neat property of switch which is that if you don't use break you can have multiple things
    // all fall into the same case
    switch(rand() % 6 + 1){

    case 1 :
      cout << "You super duper win" << endl;
      break;
    case 3:
    case 4:
    case 5:
      cout << "You win a little!" << endl;
      break;
    default:
      cout << "You lose, you so lose" << endl;
    }

    return 0;
  }
#+end_src

If you were to naively[fn:12] convert this to if-statements you might do something like this!
#+begin_src cpp :tangle codesnips/diceRollIf.cpp
  #include <iostream>
  #include <cstdlib>
  using namespace std;

  // this is a translation of the dice roll program from switches to ifs but

  int main(){
    srand(time(0));

    if((rand() % 6 + 1) == 1){
      // ...
    }
    else if(rand() % 6 + 1 == 3 || rand() % 6 + 1 == 4 || rand() % 6 + 1 == 5){
      // ...
    }
    else {
      // ...
    }
    return 0;
  }
#+end_src

Given what we've talked about, can you see the problem here? See the problem is that you're going to get a *different* random number every time you call =rand()=. So that middle condition isn't testing whether the number you rolled is 3, 4, or 5 it's doing a separate dice roll for each condition. That's very much not what you want when dealing with random number generation!

No, instead, you need to do something more like

#+begin_src cpp 
  #include <iostream>
  #include <cstdlib>
  using namespace std;

  // this is a translation of the dice roll program from switches to ifs, problems fixed

  int main(){
    srand(time(0));
    int rolledDie = rand() % 6 + 1;
    if(rolledDie == 1){
      // ...
    }
    else if(rolledDie == 3 || rolledDie == 4 || rolledDie == 5){
      // ...
    }
    else {
      // ...
    }
    return 0;
  }

#+end_src
*** Exercises
1. *Basic*: Create a days-of-week printer using switch (1=Monday, 2=Tuesday, etc.).
2. *Intermediate*: Build a simple calculator using switch for operations (+, -, *, /). Handle division by zero.
3. *Challenge*: Create a text-based restaurant ordering system with switch for menu categories (appetizers, mains, desserts) and nested switches for items.
** TODO Writing your own functions
*** TODO The basics of functions
So we've seen a couple of ways to define our own functions so far in this course, but we haven't *formally* talked about it.

Our very first function we've defined was in our "hello world" program! =main= is a function and we're defining it. It's kind of a weird function because it has to be the same every time:

#+begin_src cpp
  int main(){
    //...
  }
#+end_src

Again, this says our function is going to return a type =int=, so at some point in our function we're going to need a =return= followed by something of type =int=. Now, in the case of =main= that should almost always just be =return 0= but let's step back and recognize that it could, in theory, but anything as long as it has the right type.

The =()= after main are because the =main= function doesn't actually take any arguments! Other functions can and will!

Like, for example, consider our function for the sarcasm case up above. This function has the declaration
#+begin_src cpp
  string sarcasmCase(string s){
#+end_src
And this tells us that we're defining a function called =sarcasmCase=, it takes a =string= as an argument that we will bind to the variable =s= for the duration of the function body, and we can see that it returns a string. That means we need to make sure that we have a =return __= where the =__= needs to be something of type string.

We haven't really seen examples of it so far but you can have a bunch of function arguments[fn:14]. Like, consider this function that will let us make rows for a table.

#+begin_src cpp :tangle codesnips/rowmaker.cpp
  #include <iostream>
  #include <iomanip>
  using namespace std;

  void divider(int width){
    cout << setfill('-');
    cout << "|" << setw(width) << "";
    cout << "|" << endl;
  }

  void makeRow(int fieldWidth, string studentname, string classname, double grade){
    //we're assuming that all fields are the same width and are right aligned
    cout << setfill(' ');
    cout << right;
    cout << fixed << setprecision(2);

    cout << "|" << setw(fieldWidth) << studentname;
    cout << "|" << setw(fieldWidth) << classname;
    cout << "|" << setw(fieldWidth) << grade;
    cout << "|" << endl;
  }

  void makeTitleRow(int fieldWidth, string col1, string col2, string col3){
    cout << setfill(' ');
    cout << right;
    cout << "|" << setw(fieldWidth) << col1;
    cout << "|" << setw(fieldWidth) << col2;
    cout << "|" << setw(fieldWidth) << col3;
    cout << "|" << endl;
  }

  int main(){
    divider(47); // why is this 47? because 15*3 + one for each of the |
    makeTitleRow(15, "student", "class", "gpa");
    divider(47);
    makeRow(15, "Chicken B.", "CS 720", 2.3);
    makeRow(15, "Brad Default", "CS 250", 3.1);

    return 0;
  }
#+end_src
*** Exercises
1. *Basic*: Write a function that returns the larger of two numbers.
2. *Intermediate*: Create functions for calculating area of different shapes (circle, rectangle, triangle). Each should take appropriate parameters.
3. *Challenge*: Implement a function that checks if a number is prime. Then use it to find all twin primes (primes that differ by 2) up to 100.
*** TODO Passing by reference
Now here's a weird little feature of C++. So let's look at how arguments to functions differ from normal variables with a simple example:

#+begin_src cpp :tangle codesnips/cantAssignArgs.cpp
  #include <iostream>
  using namespace std;

  int sillyFun(int num){
    num = 10;
    return num;
  }

  int main(){

    int ourNum = 30;

    cout << "Now we're going to call our function and it'll return " << sillyFun(ourNum) << endl;
    cout << "But now what value does our variable have?: " << ourNum << endl;
  
    return 0;
  }
#+end_src

Now if you run this code you'll see that the function returns =10= but that the value of =ourNum= at the end is =30=. How is this possible? Afterall, we set =num = 10= inside the function and return =num= and that's 10! Why doesn't the assignment stick? Well, because the variable =num= inside the function =sillyFun= is not /actually/ the same as =ourNum= it's just a variable that lives inside a function and it is initialized with the same /value/ as the ourNum when it's passed in.

Okay, why am I telling you this? Because there is a different way to write functions in C++ where you don't take in the value of the argument, you are giving the function the variable itself!

For example, consider this
#+begin_src cpp :tangle codesnips/byRef1.cpp
  #include <iostream>
  using namespace std;

  int sillyFun(int &num){
    num = 10;
    return num;
  }

  int main(){
    int ourNum = 30;

    cout << "Now we're going to call our function and it'll return " << sillyFun(ourNum) << endl;
    cout << "But now what value does our variable have?: " << ourNum << endl;
  
    return 0;  
  }
#+end_src
The only difference between these programs is the little =&= symbol in front of the name of the variable. This signifies that it's an argument that is "passed by reference", or in other words it's literally passing in the variable as a thing that can be manipulated, assigned, &c. instead of just handing the function the value inside the variable.

Why use this? That's probably the obvious question to ask. So there are a few reasons. The first is that it lets you do something that C++ can't normally do: return multiple arguments!

What does that mean? So if you've ever used Python at all you might be familiar with the ability to do something like this

#+begin_src python
  def askAndSum():
      num = int(input("Enter a number: "))
      total = 0
      entries = 0
      while num >= 0:
          entries = entries + 1
          total = total + num
          num = int(input("Enter a number: "))
      return (total, entries)

  print(askAndSum())
#+end_src

This program mimics things we've seen in this class: you run a loop that keeps asking for numbers until it gets a negative entry and then it returns the sum of all the numbers *and* how many numbers got added together!

You *cannot* do this in C++. Instead, you have to write this program with a pass-by-reference argument like this:
#+begin_src cpp :tangle codesnips/byRef2.cpp
  #include <iostream>
  using namespace std;

  int askAndSum(int &entries){
    int sum = 0;
    int num = 0;
  
    cout << "Enter a number: ";
    cin >> num;

    while(num >= 0){
      entries = entries + 1;
      sum = sum + num;
    
      cout << "Enter a number: ";
      cin >> num;
    }
  
    return sum;
  }

  int main(){

    int entries = 0;
    int sum = askAndSum(entries);

    cout << sum << " " << entries << endl;
    return 0;
  }
#+end_src
*** Exercises
1. *Basic*: Write a swap function that exchanges the values of two variables using pass by reference.
2. *Intermediate*: Create a function that returns both quotient and remainder of division (use reference parameters for one of them).
3. *Challenge*: Build a function that finds minimum, maximum, and average of an array in a single pass. Use reference parameters for min and max.
** TODO Arrays, again, and Pointers
So we've covered the concept of arrays once already, to show you the basics of how they're used in C++. Now we're circling back around to cover the topic /again/. Remember how we could print all the items in an array? We did it like this:

#+begin_src cpp :tangle codesnips/arrayPrintRedux.cpp
  #include <iostream>
  using namespace std;

  int main(){
    int arr[10] = {10,11,12,13,14,15,16,17,18,19};
    for(int i =0; i<10;i++){
      cout << "The " << i << "th element is: " << arr[i] << endl;
    }
    return 0;
  }
#+end_src

Now what will happen if we print just the array like this?

#+begin_src cpp :tangle codesnips/arrayPrintMyster.cpp
  #include <iostream>
  using namespace std;

  int main(){
    int arr[10] = {10,11,12,13,14,15,16,17,18,19};
    cout << "The array is " << arr << endl;
    return 0;
  }
#+end_src

What do you think it will do? Will it print all the elements of the array? Will it print nothing? This is a slightly unfair question because unless you already /know/ about pointers you would have no way of knowing that it will produce something that looks like this:
#+begin_example
The array is 0x7ffc2ee1fa50
#+end_example

What's /that/, exactly? A number, and yes this is a number despite the letters mixed in there, that starts with =0x= is a hexadecimal number. Remember how we talked about binary being a sum of powers of two and our normal base ten is a sum of powers of ten? Hexadecimal is powers of *16*, where the "digits" used in a hex number range from 0-f rather than 0-9. Hex is a little weird to read but it's really convenient for talking about computers because each hex digit is the same as 4 bits of information.

Have you ever seen hex-codes for colors? They're usually a series of 6-hex digits because an rgb color is 24 bits,  /or 3 bytes/, i.e. 6 groups of 4 bits each.

However, when you see a big hex number in programming it's usually a memory /address/. An address is what it sounds like, it tells you where the information is stored in the computer's memory, completely analogous to a street address. 


** TODO Char Arrays
* TODO Extended example: Let's play shop
In this example we'll be writing a small program that prints out a menu, let's you select items and quantities to purchase, and prints out your total at the end.

We'll do this program "the hard way" at first, which isn't very flexible, but we'll end up showing some more features of C++ that will let us simplify and refactor this code.
** More on iteration and choices 
* TODO Extended example: An Adventure Game
In this example we're going to look at how to make an old-school text-adventure game in C++. 
* Project Ideas
** Mini-Projects (After Major Sections)
These projects are designed to be completed after finishing specific sections of the course. Each should take 1-3 hours to complete.

*** After Loops
- *Multiplication Quiz Game*: Create a timed quiz that asks multiplication problems, keeps score, and gives feedback. Include difficulty levels.
- *Password Strength Checker*: Check passwords for length, uppercase, lowercase, numbers, and special characters. Give a strength score.

*** After Arrays  
- *Class Attendance Tracker*: Track attendance for a class of students over multiple days. Calculate attendance percentages.
- *Simple Statistics Calculator*: Input a dataset and calculate mean, median, mode, and standard deviation.

*** After Functions
- *Temperature Converter Suite*: Convert between Celsius, Fahrenheit, and Kelvin with a menu-driven interface.
- *Geometry Calculator*: Calculate areas, perimeters, and volumes for various shapes using dedicated functions.

*** After Strings
- *Text-based Wordle Clone*: Implement the popular word guessing game with colored hints (use symbols for colors).
- *Simple Text Editor Commands*: Implement find/replace, word count, and case conversion operations.

*** After Data Validation
- *Robust ATM Simulator*: Handle deposits, withdrawals, balance checks with proper validation and error handling.
- *Date Calculator*: Calculate days between dates, add days to dates, handle leap years properly.

** Larger Projects
These are comprehensive projects that integrate multiple concepts. Each should take 5-10 hours to complete.

*** Store Management System
Create an inventory management system with the following features:
- Add/remove products with prices and quantities
- Search products by name or category
- Generate sales reports
- Track low inventory and suggest reorders
- Apply discounts and calculate totals
Skills practiced: Arrays, functions, data validation, formatting

*** Grade Calculator System
Build a complete gradebook application:
- Support multiple students and multiple assignments
- Weight different assignment categories (homework, tests, projects)
- Drop lowest scores option
- Calculate letter grades with +/- modifiers
- Generate grade reports with statistics
Skills practiced: 2D arrays, functions with references, data formatting

*** Game Collection
Implement 2-3 classic games in a single program:
- *Tic-Tac-Toe*: Two-player game with win detection
- *Hangman*: Word guessing with ASCII art
- *Number Baseball*: Guess a 4-digit number with hints
Include a main menu, score tracking, and play-again options
Skills practiced: Arrays, string manipulation, game logic, input validation

*** Data Analysis Tool
Create a program that reads survey or experimental data:
- Import data from user input or predefined datasets
- Calculate statistical summaries (mean, median, mode, range)
- Find correlations between variables
- Generate formatted reports with findings
- Handle missing or invalid data gracefully
Skills practiced: File I/O concepts, arrays, mathematical functions, error handling

*** Encryption Tool Suite
Build a collection of encryption/decryption methods:
- Caesar cipher with custom shifts
- Substitution cipher with custom keys
- Vigenère cipher
- ROT13
- Include encode/decode modes and file support
Skills practiced: String manipulation, algorithms, modular programming

** Project Guidelines
For each project, students should:
1. Plan the program structure before coding
2. Break the problem into smaller functions
3. Include input validation and error handling
4. Provide clear user instructions
5. Test with various inputs including edge cases
6. Comment code appropriately
7. Consider adding extra features for bonus points

** Common Mistakes to Avoid
- Not validating user input
- Forgetting to initialize variables
- Array index out of bounds
- Integer division when float division is needed
- Not handling the fail state of cin
- Memory issues with C-style strings
- Forgetting break statements in switch cases

* Sample Solutions
This chapter provides sample solutions for selected exercises from each section. Remember that there are often multiple correct ways to solve a problem in programming!

** Hello World Solutions
*** Basic: Name and Joke
#+begin_src cpp
#include <iostream>
using namespace std;

int main(){
  cout << "My name is Alex" << endl;
  cout << "Why do programmers prefer dark mode?" << endl;
  cout << "Because light attracts bugs!" << endl;
  return 0;
}
#+end_src

*** Intermediate: ASCII Art Box
#+begin_src cpp
#include <iostream>
using namespace std;

int main(){
  cout << "***********" << endl;
  cout << "* Hello   *" << endl;
  cout << "***********" << endl;
  return 0;
}
#+end_src

** String I/O Solutions
*** Basic: Last, First Format
#+begin_src cpp
#include <iostream>
using namespace std;

int main(){
  string firstName, lastName;
  
  cout << "Enter your first name: ";
  cin >> firstName;
  cout << "Enter your last name: ";
  cin >> lastName;
  
  cout << lastName << ", " << firstName << endl;
  return 0;
}
#+end_src

*** Challenge: Mad Libs
#+begin_src cpp
#include <iostream>
using namespace std;

int main(){
  string noun, verb, adjective, adverb;
  
  cout << "Enter a noun: ";
  cin >> noun;
  cout << "Enter a verb: ";
  cin >> verb;
  cout << "Enter an adjective: ";
  cin >> adjective;
  cout << "Enter an adverb: ";
  cin >> adverb;
  
  cout << "The " << adjective << " " << noun 
       << " decided to " << verb << " " << adverb << "." << endl;
  cout << "Everyone was shocked when the " << noun 
       << " began to " << verb << " so " << adverb << "!" << endl;
  
  return 0;
}
#+end_src

** Arithmetic Solutions
*** Intermediate: Tip Calculator
#+begin_src cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main(){
  double billAmount, tipPercent;
  
  cout << "Enter the bill amount: $";
  cin >> billAmount;
  cout << "Enter tip percentage (e.g., 15 for 15%): ";
  cin >> tipPercent;
  
  double tipAmount = billAmount * (tipPercent / 100);
  double total = billAmount + tipAmount;
  
  cout << fixed << setprecision(2);
  cout << "Bill: $" << billAmount << endl;
  cout << "Tip:  $" << tipAmount << endl;
  cout << "Total: $" << total << endl;
  
  return 0;
}
#+end_src

*** Challenge: Compound Interest
#+begin_src cpp
#include <iostream>
#include <iomanip>
#include <cmath>
using namespace std;

int main(){
  double principal, rate, time, n;
  
  cout << "Enter principal amount: $";
  cin >> principal;
  cout << "Enter annual interest rate (as percentage): ";
  cin >> rate;
  cout << "Enter time in years: ";
  cin >> time;
  cout << "Enter number of times compounded per year: ";
  cin >> n;
  
  // Convert percentage to decimal
  rate = rate / 100;
  
  // Formula: A = P(1 + r/n)^(nt)
  double amount = principal * pow(1 + rate/n, n*time);
  
  cout << fixed << setprecision(2);
  cout << "Final amount: $" << amount << endl;
  cout << "Interest earned: $" << amount - principal << endl;
  
  return 0;
}
#+end_src

** Boolean/If-Statement Solutions
*** Intermediate: Grade Calculator
#+begin_src cpp
#include <iostream>
using namespace std;

int main(){
  double score;
  
  cout << "Enter your numeric score (0-100): ";
  cin >> score;
  
  if(score >= 90){
    cout << "Grade: A" << endl;
  }
  else if(score >= 80){
    cout << "Grade: B" << endl;
  }
  else if(score >= 70){
    cout << "Grade: C" << endl;
  }
  else if(score >= 60){
    cout << "Grade: D" << endl;
  }
  else{
    cout << "Grade: F" << endl;
  }
  
  return 0;
}
#+end_src

*** Challenge: Eligibility Checker
#+begin_src cpp
#include <iostream>
using namespace std;

int main(){
  int age;
  
  cout << "Enter your age: ";
  cin >> age;
  
  cout << "\nBased on your age, you can legally:" << endl;
  
  if(age >= 16){
    cout << "✓ Drive (in most states)" << endl;
  }
  if(age >= 18){
    cout << "✓ Vote" << endl;
    cout << "✓ Join the military" << endl;
  }
  if(age >= 21){
    cout << "✓ Purchase alcohol" << endl;
  }
  if(age >= 25){
    cout << "✓ Rent a car (without extra fees)" << endl;
  }
  if(age >= 35){
    cout << "✓ Run for President" << endl;
  }
  
  if(age < 16){
    cout << "Sorry, you'll need to wait " << 16 - age 
         << " years before you can drive!" << endl;
  }
  
  return 0;
}
#+end_src

** While Loop Solutions
*** Intermediate: Password Checker
#+begin_src cpp
#include <iostream>
using namespace std;

int main(){
  string password = "secret123";  // The correct password
  string userInput;
  int attempts = 0;
  
  while(userInput != password && userInput != "quit"){
    cout << "Enter password (or 'quit' to exit): ";
    cin >> userInput;
    attempts++;
    
    if(userInput == password){
      cout << "Access granted! It took you " << attempts << " attempts." << endl;
    }
    else if(userInput != "quit"){
      cout << "Incorrect password. Try again." << endl;
    }
  }
  
  if(userInput == "quit"){
    cout << "Goodbye!" << endl;
  }
  
  return 0;
}
#+end_src

** Random Number Solutions
*** Intermediate: Rock, Paper, Scissors
#+begin_src cpp
#include <iostream>
#include <cstdlib>
using namespace std;

int main(){
  srand(time(0));
  
  string choices[3] = {"rock", "paper", "scissors"};
  string userChoice;
  
  cout << "Enter your choice (rock/paper/scissors): ";
  cin >> userChoice;
  
  int computerIndex = rand() % 3;
  string computerChoice = choices[computerIndex];
  
  cout << "You chose: " << userChoice << endl;
  cout << "Computer chose: " << computerChoice << endl;
  
  if(userChoice == computerChoice){
    cout << "It's a tie!" << endl;
  }
  else if((userChoice == "rock" && computerChoice == "scissors") ||
          (userChoice == "paper" && computerChoice == "rock") ||
          (userChoice == "scissors" && computerChoice == "paper")){
    cout << "You win!" << endl;
  }
  else{
    cout << "Computer wins!" << endl;
  }
  
  return 0;
}
#+end_src

*** Challenge: Coin Flip Statistics
#+begin_src cpp
#include <iostream>
#include <cstdlib>
#include <iomanip>
using namespace std;

int main(){
  srand(time(0));
  
  int flips;
  cout << "How many times should I flip the coin? ";
  cin >> flips;
  
  int heads = 0;
  int tails = 0;
  
  for(int i = 0; i < flips; i++){
    if(rand() % 2 == 0){
      heads++;
    }
    else{
      tails++;
    }
  }
  
  double headsPercent = (heads * 100.0) / flips;
  double tailsPercent = (tails * 100.0) / flips;
  
  cout << fixed << setprecision(2);
  cout << "\nResults after " << flips << " flips:" << endl;
  cout << "Heads: " << heads << " (" << headsPercent << "%)" << endl;
  cout << "Tails: " << tails << " (" << tailsPercent << "%)" << endl;
  
  return 0;
}
#+end_src

** For-Loop Solutions
*** Basic: Fibonacci Numbers
#+begin_src cpp
#include <iostream>
using namespace std;

int main(){
  int prev1 = 0, prev2 = 1;
  
  cout << "First 20 Fibonacci numbers:" << endl;
  cout << prev1 << " " << prev2 << " ";
  
  for(int i = 2; i < 20; i++){
    int current = prev1 + prev2;
    cout << current << " ";
    prev1 = prev2;
    prev2 = current;
  }
  cout << endl;
  
  return 0;
}
#+end_src

*** Intermediate: Triangle Pattern
#+begin_src cpp
#include <iostream>
using namespace std;

int main(){
  int height;
  
  cout << "Enter triangle height: ";
  cin >> height;
  
  for(int i = 1; i <= height; i++){
    for(int j = 0; j < i; j++){
      cout << "*";
    }
    cout << endl;
  }
  
  return 0;
}
#+end_src

*** Challenge: Prime Numbers
#+begin_src cpp
#include <iostream>
#include <cmath>
using namespace std;

bool isPrime(int n){
  if(n <= 1) return false;
  if(n == 2) return true;
  if(n % 2 == 0) return false;
  
  for(int i = 3; i <= sqrt(n); i += 2){
    if(n % i == 0) return false;
  }
  return true;
}

int main(){
  cout << "Prime numbers between 1 and 100:" << endl;
  
  for(int i = 2; i <= 100; i++){
    if(isPrime(i)){
      cout << i << " ";
    }
  }
  cout << endl;
  
  return 0;
}
#+end_src

** Array Solutions
*** Basic: Temperature Analysis
#+begin_src cpp
#include <iostream>
using namespace std;

int main(){
  double temps[7];
  
  cout << "Enter temperatures for 7 days:" << endl;
  for(int i = 0; i < 7; i++){
    cout << "Day " << i+1 << ": ";
    cin >> temps[i];
  }
  
  int warmestDay = 0;
  int coldestDay = 0;
  
  for(int i = 1; i < 7; i++){
    if(temps[i] > temps[warmestDay]){
      warmestDay = i;
    }
    if(temps[i] < temps[coldestDay]){
      coldestDay = i;
    }
  }
  
  cout << "Warmest day was Day " << warmestDay + 1 
       << " with " << temps[warmestDay] << " degrees" << endl;
  cout << "Coldest day was Day " << coldestDay + 1 
       << " with " << temps[coldestDay] << " degrees" << endl;
  
  return 0;
}
#+end_src

*** Intermediate: Array Reversal
#+begin_src cpp
#include <iostream>
using namespace std;

int main(){
  int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  
  cout << "Original array: ";
  for(int i = 0; i < 10; i++){
    cout << arr[i] << " ";
  }
  cout << endl;
  
  // Reverse in-place
  for(int i = 0; i < 5; i++){
    int temp = arr[i];
    arr[i] = arr[9-i];
    arr[9-i] = temp;
  }
  
  cout << "Reversed array: ";
  for(int i = 0; i < 10; i++){
    cout << arr[i] << " ";
  }
  cout << endl;
  
  return 0;
}
#+end_src

** String Operation Solutions
*** Basic: Vowel Counter
#+begin_src cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
  string text;
  int vowelCount = 0;
  
  cout << "Enter some text: ";
  getline(cin, text);  // Use getline to get entire line including spaces
  
  for(int i = 0; i < text.length(); i++){
    char c = tolower(text[i]);
    if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'){
      vowelCount++;
    }
  }
  
  cout << "Number of vowels: " << vowelCount << endl;
  
  return 0;
}
#+end_src

*** Intermediate: Palindrome Checker
#+begin_src cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
  string text;
  cout << "Enter a word: ";
  cin >> text;
  
  bool isPalindrome = true;
  int len = text.length();
  
  for(int i = 0; i < len/2; i++){
    if(tolower(text[i]) != tolower(text[len-1-i])){
      isPalindrome = false;
      break;
    }
  }
  
  if(isPalindrome){
    cout << "\"" << text << "\" is a palindrome!" << endl;
  }
  else{
    cout << "\"" << text << "\" is not a palindrome." << endl;
  }
  
  return 0;
}
#+end_src

** Switch Statement Solutions
*** Intermediate: Calculator
#+begin_src cpp
#include <iostream>
using namespace std;

int main(){
  double num1, num2;
  char operation;
  
  cout << "Enter first number: ";
  cin >> num1;
  cout << "Enter operation (+, -, *, /): ";
  cin >> operation;
  cout << "Enter second number: ";
  cin >> num2;
  
  switch(operation){
    case '+':
      cout << num1 << " + " << num2 << " = " << num1 + num2 << endl;
      break;
    case '-':
      cout << num1 << " - " << num2 << " = " << num1 - num2 << endl;
      break;
    case '*':
      cout << num1 << " * " << num2 << " = " << num1 * num2 << endl;
      break;
    case '/':
      if(num2 != 0){
        cout << num1 << " / " << num2 << " = " << num1 / num2 << endl;
      }
      else{
        cout << "Error: Division by zero!" << endl;
      }
      break;
    default:
      cout << "Invalid operation!" << endl;
  }
  
  return 0;
}
#+end_src

** Function Solutions
*** Basic: Larger of Two Numbers
#+begin_src cpp
#include <iostream>
using namespace std;

int larger(int a, int b){
  if(a > b){
    return a;
  }
  else{
    return b;
  }
  // Could also write: return (a > b) ? a : b;
}

int main(){
  int num1, num2;
  
  cout << "Enter two numbers: ";
  cin >> num1 >> num2;
  
  cout << "The larger number is: " << larger(num1, num2) << endl;
  
  return 0;
}
#+end_src

*** Intermediate: Area Calculators
#+begin_src cpp
#include <iostream>
#include <cmath>
using namespace std;

double circleArea(double radius){
  return 3.14159 * radius * radius;
}

double rectangleArea(double length, double width){
  return length * width;
}

double triangleArea(double base, double height){
  return 0.5 * base * height;
}

int main(){
  int choice;
  
  cout << "Area Calculator" << endl;
  cout << "1. Circle" << endl;
  cout << "2. Rectangle" << endl;
  cout << "3. Triangle" << endl;
  cout << "Choose shape (1-3): ";
  cin >> choice;
  
  switch(choice){
    case 1:{
      double radius;
      cout << "Enter radius: ";
      cin >> radius;
      cout << "Area: " << circleArea(radius) << endl;
      break;
    }
    case 2:{
      double length, width;
      cout << "Enter length: ";
      cin >> length;
      cout << "Enter width: ";
      cin >> width;
      cout << "Area: " << rectangleArea(length, width) << endl;
      break;
    }
    case 3:{
      double base, height;
      cout << "Enter base: ";
      cin >> base;
      cout << "Enter height: ";
      cin >> height;
      cout << "Area: " << triangleArea(base, height) << endl;
      break;
    }
    default:
      cout << "Invalid choice!" << endl;
  }
  
  return 0;
}
#+end_src

** Pass by Reference Solutions
*** Basic: Swap Function
#+begin_src cpp
#include <iostream>
using namespace std;

void swap(int &a, int &b){
  int temp = a;
  a = b;
  b = temp;
}

int main(){
  int x = 5, y = 10;
  
  cout << "Before swap: x = " << x << ", y = " << y << endl;
  swap(x, y);
  cout << "After swap: x = " << x << ", y = " << y << endl;
  
  return 0;
}
#+end_src

*** Intermediate: Division with Quotient and Remainder
#+begin_src cpp
#include <iostream>
using namespace std;

int divide(int dividend, int divisor, int &remainder){
  remainder = dividend % divisor;
  return dividend / divisor;
}

int main(){
  int num1, num2;
  int remainder;
  
  cout << "Enter dividend: ";
  cin >> num1;
  cout << "Enter divisor: ";
  cin >> num2;
  
  if(num2 != 0){
    int quotient = divide(num1, num2, remainder);
    cout << num1 << " / " << num2 << " = " << quotient 
         << " with remainder " << remainder << endl;
  }
  else{
    cout << "Error: Cannot divide by zero!" << endl;
  }
  
  return 0;
}
#+end_src

*** Challenge: Array Statistics
#+begin_src cpp
#include <iostream>
using namespace std;

double analyzeArray(int arr[], int size, int &min, int &max){
  min = arr[0];
  max = arr[0];
  double sum = arr[0];
  
  for(int i = 1; i < size; i++){
    if(arr[i] < min) min = arr[i];
    if(arr[i] > max) max = arr[i];
    sum += arr[i];
  }
  
  return sum / size;  // Return average
}

int main(){
  int numbers[10];
  int min, max;
  
  cout << "Enter 10 numbers:" << endl;
  for(int i = 0; i < 10; i++){
    cout << "Number " << i+1 << ": ";
    cin >> numbers[i];
  }
  
  double avg = analyzeArray(numbers, 10, min, max);
  
  cout << "\nStatistics:" << endl;
  cout << "Minimum: " << min << endl;
  cout << "Maximum: " << max << endl;
  cout << "Average: " << avg << endl;
  
  return 0;
}
#+end_src

** Data Validation Solutions
*** Challenge: Date Validator
#+begin_src cpp
#include <iostream>
using namespace std;

bool isLeapYear(int year){
  return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

bool isValidDate(int month, int day, int year){
  if(year < 1 || year > 9999) return false;
  if(month < 1 || month > 12) return false;
  
  int daysInMonth;
  switch(month){
    case 2:
      daysInMonth = isLeapYear(year) ? 29 : 28;
      break;
    case 4: case 6: case 9: case 11:
      daysInMonth = 30;
      break;
    default:
      daysInMonth = 31;
  }
  
  return day >= 1 && day <= daysInMonth;
}

int main(){
  int month, day, year;
  
  cout << "Enter a date (MM DD YYYY): ";
  cin >> month >> day >> year;
  
  while(cin.fail() || !isValidDate(month, day, year)){
    if(cin.fail()){
      cin.clear();
      cin.ignore(256, '\n');
      cout << "Invalid input! Please enter numbers only." << endl;
    }
    else{
      cout << "Invalid date! ";
      if(month < 1 || month > 12){
        cout << "Month must be 1-12." << endl;
      }
      else if(month == 2 && day > 29){
        cout << "February cannot have more than 29 days." << endl;
      }
      else if(month == 2 && day == 29 && !isLeapYear(year)){
        cout << year << " is not a leap year." << endl;
      }
      else{
        cout << "Day is invalid for this month." << endl;
      }
    }
    cout << "Enter a date (MM DD YYYY): ";
    cin >> month >> day >> year;
  }
  
  cout << "Valid date: " << month << "/" << day << "/" << year << endl;
  
  return 0;
}
#+end_src

** Notes on Solutions
These solutions demonstrate various programming concepts and best practices:

1. **Input validation**: Always check user input for validity
2. **Edge cases**: Consider special cases like division by zero
3. **Code organization**: Use functions to break down complex problems
4. **Comments**: While not heavily commented here, production code should include explanations
5. **Efficiency**: Some solutions prioritize clarity over optimization for learning purposes
6. **Alternative approaches**: Many problems have multiple valid solutions

Remember: The best solution is one that works correctly, is readable, and can be maintained. As you gain experience, you'll develop your own coding style and preferences.

* Footnotes
[fn:8] Okay, what on earth does "less precise" mean in this context? Okay, let's talk about sizes of infinity. No, really, I promise that this isn't a tangent. So the whole numbers, the integers, are infinite. You can start counting in either direction---positive or negative---and you'll never reach the end. This is the smallest infinity though. The numbers that have decimals, which are the "real numbers", are much bigger than the whole numbers. There are more real numbers between 0 and 1 than the entirety of the integers. The reason for this is, in a sense, is because a real number can have an infinite number of digits to the right of the decimal point. The problem for us, as computer scientists, is that there's no way to represent "an infinite number of digits" in a way that can fit in a finite amount of memory. So, instead, we have to compromise and instead of representing *all* possible real numbers we represent *some* of them. How well we can represent a number is the "precision". The higher the precision, the more fine-grained of distinctions we can make between representing two real numbers.


[fn:6] I literally forget constantly and have to go back and fix my examples. If you've had me for in-person lecture you have definitely seen this happen. 

[fn:7] A compiler is a thing that takes source code and turns it into a stand alone program. The act of turning the code into the stand alone program is called "compiling". If you dealt with Python or JavaScript or even something like Scratch before you were probably interacting with "interpreters", which are programs that take the code and run it. Now, some people talk about "compiled" or "interpreted" languages. This is wrong. A language per se isn't compiled or interpreted. A language is a language and can be run---albeit slowly---with a pencil and paper and no compiler or interpreter in sight. 

[fn:5]Okay, so I do actually encourage you to---whenever possible---try to answer questions you have about how code works by trying to make a program that tests out the idea. This will get easier as you learn more about coding, but it's just a good habit to get into and you'd be surprised by how many people never learn to think this way: coding is not a passive enterprise but an active art practice. Learn by trying things! 

[fn:4]Oh look a footnote in a footnote: I say "typed" and "untyped" rather than "static" and "dynamic". This is more technically correct and I will not be taking questions at this time.

[fn:3] Oh boy, are types actually a huge topic. Way bigger than you'd think. Okay, so in C++ types are very weak. They prevent fairly limited kinds of errors. They won't let you treat an int as a string or visa versa. But! As we'll see in a bit they let you still do some pretty weird things like conflate 0,1, =true=, and =false=. The types in C++ also don't prevent errors like blasting past the end of a list of items and grabbing random chunks of the computer's memory. You can break C++ code in so many ways it honestly makes you wonder what the point of types at all, are, if this is what people tell you typed languages are like[fn:4]. A-ha! But, in reality, types in programming languages can be terrifyingly powerful. Rust uses types to guarantee memory safety. Haskell uses types to ensure that the compiler can do absolutely wild optimizations, including writing programs that involve generating "infinite data". Languages like Agda and Coq use types to bridge the gap between how mathematicians work and how programmers work, making the act of writing theorems and proofs a kind of programming! It's a great topic. Feel free to ask me about it. 


[fn:2] Is that too specific? Is the author of this portion telling on themselves?

[fn:1] bet you never saw that coming! 


